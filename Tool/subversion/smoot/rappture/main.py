# ----------------------------------------------------------------------
#  MAIN PROGRAM - generated by the Rappture Builder
# ----------------------------------------------------------------------
import Rappture
import sys
import numpy as np
import pickle as pkl
import dill
import base64
from ast import literal_eval
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
import design
import matplotlib
matplotlib.use('PS')
from matplot import * # MATPLOT GOES BEFORE ANYTHING ELSE
from pydes import *
from mpl_toolkits.mplot3d import Axes3D
from math import *
import math
import csv
import copy
import shutil

# uncomment these to redirect stdout and stderr
# to files for debugging.
my_log = open('log.log','wb')
#sys.stderr = open('debug.err', 'wb')
#sys.stdout = open('debug.out', 'w')

# open the XML file containing the run parameters
io = Rappture.PyXml(sys.argv[1])

#########################################################
# Get input values from Rappture
#########################################################


#Inputs from csv files

# get input value for input.string(x_in)
#x_in = io['input.string(x_in).current'].value

# get input value for input.string(y_in)
#y_in = io['input.string(y_in).current'].value

# get input value for input.phase(initial_inputs).boolean(csv_observations)
# returns value as string "yes" or "no"
csv_valid = io['input.phase(initial_inputs).boolean(csv_valid).current'].value == 'yes'

# get input value for input.phase(desc).note(note)
note = io['input.phase(desc).note(note).current'].value

# get input value for input.phase(initial_inputs).note(note_setp_2)
note_setp_2 = io['input.phase(initial_inputs).note(note_setp_2).current'].value

# get input value for input.phase(initial_inputs).string(inputs)
inputs = io['input.phase(initial_inputs).string(inputs).current'].value

# get input value for input.phase(initial_inputs).string(outputs)
outputs = io['input.phase(initial_inputs).string(outputs).current'].value

# get input value for input.phase(initial_inputs).string(l_bounds)
l_bounds = io['input.phase(initial_inputs).string(l_bounds).current'].value

# get input value for input.phase(initial_inputs).string(u_bounds)
u_bounds = io['input.phase(initial_inputs).string(u_bounds).current'].value

# get input value for input.phase(initial_inputs).integer(max_it)
max_it = int(io['input.phase(initial_inputs).integer(max_it).current'].value)

# get input value for input.phase(iterative_run).note(note_step_3)
note_step_3 = io['input.phase(iterative_run).note(note_step_3).current'].value

# get input value for input.phase(iterative_run).boolean(finish)
# returns value as string "yes" or "no"
finish = io['input.phase(iterative_run).boolean(finish).current'].value == 'yes'

# get input value for input.phase(iterative_run).string(new_result)
new_result = io['input.phase(iterative_run).string(new_result).current'].value

#Pareto data
pareto_data = None

#X designs
designs = None

#########################################################
#  Add your code here for the main body of your program
#########################################################

########################################################
# My methods
########################################################

def format_csv_files():
	global inputs, outputs, x_datalist, y_datalist

	x_datastr=list(inputs.split('\n'))
	y_datastr=list(outputs.split('\n'))

	for i in range(len(x_datastr)):
		x_datalist.append(tuple(map(float,x_datastr[i].split(','))))
	for i in range(len(y_datastr)):
		y_datalist.append(tuple(map(float,y_datastr[i].split(','))))

	x_datalist = tuple(x_datalist)
	y_datalist = tuple(y_datalist)

def format_csv_file_new_result():
	'''
	Creates a tuple from csv file for the new result
	'''
	global new_result

	new_result = tuple(map(float,new_result.split(',')))

def check_observations():
	'''
	Check for all the input observations to be empty or to have the correct tuple
	format
	'''
	my_log.write('Checking observations\n')
	global inputs, outputs, l_bounds, u_bounds, max_it, csv_valid
	try:
		if csv_valid:
			try:
				format_csv_files()
				check_inputs = True
				check_outputs = True
			except Exception, e:
				my_log.write(str(e))
				check_inputs = False
				check_outputs = False
		else:
			check_inputs = isinstance(literal_eval(inputs), tuple)
			check_outputs = isinstance(literal_eval(outputs), tuple)

		check_l_bounds = isinstance(literal_eval(l_bounds), tuple)
		check_u_bounds = isinstance(literal_eval(u_bounds), tuple)
		check_max_it = isinstance(max_it,int)

		check = check_inputs and check_outputs and check_l_bounds and check_u_bounds and check_max_it

		return check
	except Exception, e:
		my_log.write(str(e))
		return False

def check_new_result():
	'''
	Checks that the new result has the correct tuple format
	'''
	global new_result
	try:
		new_result = tuple(map(float,new_result.split(',')))
		return True
	except:
		return False

def existing_model():
	'''Looks for a previous model'''
	return os.path.isfile('model.obj')

def restart():
	'''Restarts the program'''
	try:
		os.system('rm model.obj')
		os.system('rm -rf surf_test_results_noisy_moo/')
	except:
		pass

def new_optimization():
	global inputs, outputs, l_bounds, u_bounds, max_it, x_datalist, y_datalist, csv_valid, pareto_data, designs
	response = None
	my_log.write('New optimization...\n')
	if check_observations():
		Rappture.Utils.progress(10, "New model being created...")
		out_dir = 'surf_test_results_noisy_moo'
		if os.path.isdir(out_dir):
			shutil.rmtree(out_dir)
		os.makedirs(out_dir)

		if csv_valid:
			X_init = x_datalist
			Y_init = y_datalist
		else:
			X_init = literal_eval(inputs)
			Y_init = literal_eval(outputs)

		X_init = np.array(X_init)
		Y_init = np.array(Y_init)

		a = literal_eval(l_bounds)
		b = literal_eval(u_bounds)
		a = np.array(a)
		b = np.array(b)
		X_design = (b-a)*design.latin_center(1000, 2, seed=314519) + a
		my_log.write('Creating Pareto model...\n')
		pareto_model = ParetoFront(X_init, Y_init, X_design=X_design, gp_opt_num_restarts=50, verbose=False, max_it=max_it, make_plots=True, add_at_least=30, get_fig=get_full_fig, fig_prefix=os.path.join(out_dir,'ex1'), Y_true_pareto=None, gp_fixed_noise=None, samp=100, denoised=True)
		my_log.write('Pareto model created...\n')
		Rappture.Utils.progress(20, "Performing optimization algorithm...")
		my_log.write('Starting optimization algorithm...\n')
		pareto_model.optimize_paused()
		response = pareto_model.response
		pareto_data = pareto_model.get_pareto_data()
		designs = pareto_model.get_X_design()
		my_log.write('Optimization finished, saving the model...\n')
		Rappture.Utils.progress(60, "Saving the model...")
		model_file = open('model.obj','wb')
		pkl.dump(pareto_model, model_file, pkl.HIGHEST_PROTOCOL)
		model_file.close()
		my_log.write('Process completed...\n')
		Rappture.Utils.progress(100, "Done...")

	else:
		my_log.write('Incorrect input values, finishing execution...\n')
		response = 'Incorrect tuples for new model'

	return response

def continue_optimization():
	global finish, pareto_data, designs
	response = None
	my_log.write('Continue optimization...\n')
	if finish:
		my_log.write('Restarting program...\n')
		restart()
		response = 'Program restarted, enter new input observations'
		my_log.write('Program restarted...\n')
	elif check_new_result():
		my_log.write('Loading previous model...\n')
		Rappture.Utils.progress(10, "Loading previous model...")
		model_file = open('model.obj','rb')
		pareto_model = pkl.load(model_file)
		model_file.close()
		my_log.write('Model loaded, performing optimization...\n')
		Rappture.Utils.progress(20, "Performing optimization algorithm...")
		pareto_model.optimize_paused(new_result)
		response = pareto_model.response
		pareto_data = pareto_model.get_pareto_data()
		designs = pareto_model.get_X_design()
		my_log.write('Finished optimization, Pareto data available...\n')
		Rappture.Utils.progress(60, "Saving the model...")
		my_log.write('Saving the model...\n')
		model_file = open('model.obj','wb')
		pkl.dump(pareto_model, model_file, pkl.HIGHEST_PROTOCOL)
		model_file.close()
		Rappture.Utils.progress(100, "Done...")
		my_log.write('Model saved, finished execution...\n')
	else:
		response = 'Incorrect tuple for new result'
		my_log.write('Incorrect input for new observation...\n')

	return response

#Check for a previous state of the program

x_datalist=[]
y_datalist=[]
my_log.write('Start...\n')
Rappture.Utils.progress(0, "Starting...")
if not existing_model():
	new_design = new_optimization()
else:
	new_design = continue_optimization()

#Pareto front
path = 'surf_test_results_noisy_moo/'
try:
	fronts = [front for front in os.listdir(path) if front.endswith('.png')]
	if len(fronts) == 0:
		image_path = 'no_pareto.png'
	else:
		fronts.sort()
		last_front = fronts[len(fronts) - 1]
		image_path = path + last_front
except:
	image_path = 'no_pareto.png'

with open(image_path,'rb') as img:
	imdata = base64.b64encode(img.read())

#########################################################
# Save output values back to Rappture
#########################################################

# save output value for output.string(new_design)
io['output.string(new_design).current'] = new_design

# save output value for output.image(pareto_front)
# data should be base64-encoded image data
io['output.image(pareto_front).current'] = imdata

#Pareto plot
#test data
if pareto_data is not None:
	my_log.write('Pareto data generated:\n')
	my_log.write('Front size: ' + str(len(pareto_data)) + '\n')
	my_log.write('Pareto data: \n' + str(pareto_data) + '\n')
	my_log.write('X designs: \n')
	my_log.write('Designs size: ' + str(len(designs)) + '\n')
	my_log.write('Designs data: \n' + str(designs) + '\n')
	x = pareto_data[:,0]
	y = pareto_data[:,1]
else:
	x = [1]
	y = [1]

io['output.curve(scatter).component.xy'] = (x,y)

#save csv formats for the pareto data and the designs
line = ''
if pareto_data is not None:
	for i in xrange(len(x)):
		if i == len(x) - 1 :
			line += str(x[i]) + ',' + str(y[i]) 
		else:
			line += str(x[i]) + ',' + str(y[i]) + '\n'

io['output.string(y_pareto).current'] = line

line = ''
if designs is not None:
	x_1 = designs[:,0]
	x_2 = designs[:,1]
	for i in xrange(len(x_1)):
		if i == len(x_1) - 1 :
			line += str(x_1[i]) + ',' + str(x_2[i])
		else:
			line += str(x_1[i]) + ',' + str(x_2[i]) + '\n'

io['output.string(x_pareto).current'] = line

io.close()
my_log.close()
sys.exit()
